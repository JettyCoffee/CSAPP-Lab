BombLab Comeout
Answer of each bomb:
When a problem comes along, you must zip it!
0 1 3 6 10 15
1 470
9 27
5 115
4 2 1 3 6 5
下面对每个题目进行简要的分析和拆弹思路
首先对bomb64反编译后，得到了bomb64.asm的汇编代码文件，通过简要观察可以发现程序从main函数一次跳转不同的phase，那么每个炸弹的具体实现就在具体的phase区段内
<<phase1>>
第一题很简单，目的就是需要输入和程序预设一样的字符串，在15ef的lea地址偏移可以发现
预设的字符串储存在0x3150处，使用gdb调用发现字符串为(image1)
<<phase2>>
第二题最显眼的莫过于1628处的<read_six_numbers>，通过查看函数可以发现函数在0x3323处调用如下(image2)
由此可以判断第二题需要我们输入六个数字
后续的代码可以看出对输入主要有以下两个要求：
1.在162d处的cmpl要求第一个数为非负数
2.六个数需满足a[i] = a[i-1] + i
因此假设a[0] = 0,得到a[1] = 1依次递归即可得解
<<phase3>>
第三题开始从0x332f要求我们输入两个整数，然后根据第一个数做偏移计算，且第一个数要小于7
Switch跳转到与第二个输入作比较的地址，通过gdb调试可以发现数字1对应的是地址为0x1d6的值470
<<phase4>>
第四题与前一题一样需要我们输入两个数，通过eax与2做cmp验证输入数量。
随后179f的cmpl要求第一个数小于12,17bc的cmp要求经由func4计算的结果为27
17c1的cmpl要求第二个数也为27。而通过观察fun4的功能发现其实现的是函数嵌套递归
通过gdb对func前后打断点，测试得出初始输入应为9，进而得到答案9 27
<<phase5>>
第五题开始是和前面一样的设置栈帧，而后从0x332f可得需输入两个数
1818-1821表明将第一个数与0xf按位取与，而后又与0xf做cmp，可得第一个输入需小于15
而后通过观察1837-1844的while循环，每次循环内计数器edx++，ecx = array[eax],而eax的值为下一循环的数组标号
而当eax的值为15时跳出循环，而后立刻检测第二个输入是否与ecx的值相等和计数器edx == 15
而数组array数据存储在0x31e0，通过gdb调用发现数组数据如下(image3)
通过反推可以得出答案5 115
<<phase6>>
phase6的开始是对数个寄存器压入栈，紧接着调用read_six_number读取输入的六个数字，
根据后面的内容我们知道这六个数字代表了重构链表的顺序
而后经过初始赋值后跳转至18dc-18ef检测输入是否都在1-6且只有6个数字
在18f6-1971所做的是依据输入的数字，找到对应的node i，按输入数字顺序重构链表
而后在1973-1979一次检测链表是否为递增顺序
通过查找可发现node1在0x5210，依次gdb查找得出所有node的值如下












Array of phase 5
10 2 14 7 8 12 15 11 0 4 1  13 3  9  6  5
0  1 2  3 4 5  6  7  8 9 10 11 12 13 14 15